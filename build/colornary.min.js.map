{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///colornary.min.js","webpack:///webpack/bootstrap 1b22cb9abb7bed57f47a","webpack:///./src/utils/index.js","webpack:///./src/conversions/index.js","webpack:///./src/utils/parse-color.js","webpack:///./src/conversions/hsl.js","webpack:///./src/conversions/rgb.js","webpack:///./src/index.js","webpack:///./src/utils/equal-arrays.js","webpack:///./src/utils/convenience-to-hsla.js","webpack:///./src/conversions/hsla.js","webpack:///./src/conversions/rgba.js","webpack:///./src/manipulations/index.js","webpack:///./src/manipulations/luminance.js","webpack:///./src/manipulations/saturation.js","webpack:///./src/manipulations/opacity.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","value","_parseColor","_equalArrays","_convenienceToHsla","_interopRequireWildcard","newObj","key","toJSON","toRgba","toRgb","toHex","toHsla","toHsl","undefined","_parseColor2","_hsl","hsl","_hsla","hsla","_rgb","rgb","_rgba","rgba","conversions","$color","hslColor","colorObject","type","color","err","console","error","hslaColor","hexColor","rgbColor","rgbaColor","jsonColor","_typeof","Symbol","iterator","constructor","_","parseRgbString","rgbString","values","match","map","parseInt","length","Error","r","g","b","format","parseRgbaString","rgbaString","slice","alpha","parseFloat","a","parseHslString","hslString","hue","RegExp","perc","test","replace","h","parseHslaString","hslaString","Number","parseHexString","hexString","hex","split","repeat","join","parseColorString","colorString","parseColorObject","keys","toLowerCase","equalArrays","parseColor","parsedColor","red","green","blue","chroma","Math","abs","hueDiv","sec","round","adjColor","toString","max","min","luminance","saturation","num","_conversions","_manipulations","darken","lighten","saturate","desaturate","opacify","transparentize","equalsArray","arr1","arr2","sort","_utils","convert","convenienceToHsla","parsed","subScript","toUpperCase","includes","toOriginalColorType","newColor","_luminance","_saturation","_opacity","_extends","assign","target","arguments","source","alterLuminance","factor","lum","adjLum","warn","alterSaturation","sat","adjSat","alterOpacity","adjAlpha"],"mappings":"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","file":"colornary.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"colornary\"] = factory();\n\telse\n\t\troot[\"colornary\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"colornary\"] = factory();\n\telse\n\t\troot[\"colornary\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parseColor = __webpack_require__(2);\n\nObject.defineProperty(exports, 'parseColor', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_parseColor).default;\n  }\n});\n\nvar _equalArrays = __webpack_require__(6);\n\nObject.defineProperty(exports, 'equalArrays', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_equalArrays).default;\n  }\n});\n\nvar _convenienceToHsla = __webpack_require__(7);\n\nObject.defineProperty(exports, 'convenienceToHsla', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_convenienceToHsla).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toJSON = exports.toRgba = exports.toRgb = exports.toHex = exports.toHsla = exports.toHsl = undefined;\n\nvar _parseColor = __webpack_require__(2);\n\nvar _parseColor2 = _interopRequireDefault(_parseColor);\n\nvar _hsl = __webpack_require__(3);\n\nvar hsl = _interopRequireWildcard(_hsl);\n\nvar _hsla = __webpack_require__(8);\n\nvar hsla = _interopRequireWildcard(_hsla);\n\nvar _rgb = __webpack_require__(4);\n\nvar rgb = _interopRequireWildcard(_rgb);\n\nvar _rgba = __webpack_require__(9);\n\nvar rgba = _interopRequireWildcard(_rgba);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar conversions = {\n  hsl: hsl,\n  hsla: hsla,\n  rgb: rgb,\n  rgba: rgba\n};\n\n/**\n * Converts color to Hsl\n * \n * @param {string|object} $color\n * @return {string} - Hsl string  \n */\nvar toHsl = exports.toHsl = function toHsl($color) {\n  var hslColor = void 0;\n  try {\n    var colorObject = (0, _parseColor2.default)($color);\n    var type = colorObject.type,\n        color = colorObject.color;\n\n    hslColor = conversions[type].toHsl(color);\n  } catch (err) {\n    console.error(err);\n  }\n  return hslColor;\n};\n\n/**\n * Converts color to Hsla\n * \n * @param {string|object} $color\n * @return {string} - Hsla string  \n */\nvar toHsla = exports.toHsla = function toHsla($color) {\n  var hslaColor = void 0;\n  try {\n    var colorObject = (0, _parseColor2.default)($color);\n    var type = colorObject.type,\n        color = colorObject.color;\n\n    hslaColor = conversions[type].toHsla(color);\n  } catch (err) {\n    console.error(err);\n  }\n  return hslaColor;\n};\n\n/**\n * Converts color to Hex\n * \n * @param {string|object} $color\n * @returns {string} - Hex string\n */\nvar toHex = exports.toHex = function toHex($color) {\n  var hexColor = void 0;\n  try {\n    var colorObject = (0, _parseColor2.default)($color);\n    var type = colorObject.type,\n        color = colorObject.color;\n\n    hexColor = conversions[type].toHex(color);\n  } catch (err) {\n    console.error(err);\n  }\n  return hexColor;\n};\n\n/**\n * Converts color to RGB\n * \n * @param {string|object} $color\n * @returns {string} - RGB CSS string\n */\nvar toRgb = exports.toRgb = function toRgb($color) {\n  var rgbColor = void 0;\n  try {\n    var colorObject = (0, _parseColor2.default)($color);\n    var type = colorObject.type,\n        color = colorObject.color;\n\n    rgbColor = conversions[type].toRgb(color);\n  } catch (err) {\n    console.error(err);\n  }\n  return rgbColor;\n};\n\n/**\n * Converts color to RGBA\n * \n * @param {string|object} $color\n * @returns {string} - RGBA CSS string\n */\nvar toRgba = exports.toRgba = function toRgba($color) {\n  var rgbaColor = void 0;\n  try {\n    var colorObject = (0, _parseColor2.default)($color);\n    var type = colorObject.type,\n        color = colorObject.color;\n\n    rgbaColor = conversions[type].toRgba(color);\n  } catch (err) {\n    console.error(err);\n  }\n  return rgbaColor;\n};\n\n/**\n * Converts color to JSON\n * \n * @param {string|object} $color\n * @returns {object} - Color JSON\n */\nvar toJSON = exports.toJSON = function toJSON(color) {\n  var jsonColor = void 0;\n  try {\n    jsonColor = (0, _parseColor2.default)(color).color;\n  } catch (err) {\n    console.error(err);\n  }\n  return jsonColor;\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _ = __webpack_require__(0);\n\n/**\n * Parses RGB string\n * Assumes format `rgb([red], [green], [blue])`\n * \n * Deconstructs RGB CSS string: gets all three, 0-255 values\n * (red, green, blue). The values are then mapped to a color\n * object for manipulation/conversion.\n * @param {string} rgbString\n * @throws if missing rgb values\n * @returns {object} - parsed RGB color object\n */\nvar parseRgbString = function parseRgbString(rgbString) {\n  // deconstruct rgb\n  var values = rgbString.match(/(2[0-5]\\d|1\\d{2}|\\d{1,2})/g).map(function (n) {\n    return parseInt(n, 10);\n  });\n  if (values.length !== 3) throw new Error('Invalid RGB String');\n  var color = { r: values[0], g: values[1], b: values[2] };\n  // return color object\n  return { color: color, format: 'string', type: 'rgb' };\n};\n\n/**\n * Parses RGBA string\n * Assumes format: `rgba([red], [green], [blue], [alpha])`\n * \n * Deconstructs RGBA CSS string: first getting all three, 0-255\n * values (red, green, blue), then the alpha channel. The values\n * are then mapped to a color object for manipulation/conversion.\n * @param {string} rgbaString\n * @throws if missing RGB / alpha values\n * @returns {object} - parsed RGB color object\n */\nvar parseRgbaString = function parseRgbaString(rgbaString) {\n  // deconstruct rgba string\n  var values = rgbaString.match(/(2[0-5]\\d|1\\d{2}|\\d{1,2}),/g).map(function (s) {\n    return parseInt(s.slice(0, -1), 10);\n  });\n  if (values.length !== 3) throw new Error('Invalid RGBA String');\n  var alpha = parseFloat(rgbaString.match(/(1(\\.0)?|0(\\.\\d+)?)\\)/)[0].slice(0, -1));\n  var color = { r: values[0], g: values[1], b: values[2], a: alpha };\n  // return color object\n  return { color: color, format: 'string', type: 'rgba' };\n};\n\n/**\n * Parses HSL string\n * Assumes format: `hsl([hue], [saturation], [luminance])`\n * \n * Deconstructs HSL CSS string: first getting the hue, then the\n * percentages (saturation and luminance). The values are then\n * mapped to a color object for manipulation/conversion.\n * @param {string} hslString\n * @throws if missing HSL values\n * @returns {object} - parsed HSL color object\n */\nvar parseHslString = function parseHslString(hslString) {\n  // Deconstruct hsl string\n  var degPattern = '(360|3[0-5]\\\\d|[12]\\\\d{2}|[1-9]?\\\\d|\\\\d)(deg)?';\n  var turnPattern = '(1(\\\\.0+)?|0(\\\\.\\\\d+)?)';\n  var hue = hslString.match(new RegExp('\\\\((' + degPattern + '|' + turnPattern + ')', 'g'));\n  var perc = hslString.match(/[\\s,](100|[1-9]?\\d)%/g).map(function (s) {\n    return parseInt(s.slice(1, -1), 10) / 100;\n  });\n  if (perc.length !== 2 || hue.length !== 1) throw new Error('Invalid HSL String');\n  // Normalize hue\n  if (/deg/.test(hue)) hue = hue[0].slice(1).replace('deg', '');else if (/turn/.test(hue)) hue = parseInt(hue[0].slice(1).replace('turn', ''), 10) * 360;else hue = hue[0].slice(1);\n  hue = parseInt(hue, 10);\n  var color = { h: hue, s: perc[0], l: perc[1] };\n  // Return color object\n  return { color: color, format: 'string', type: 'hsl' };\n};\n\n/**\n * Parses HSLA string\n * Assumes format: `hsla([hue], [saturation], [luminance], [alpha])`\n * \n * Deconstructs HSLA CSS string: first getting the hue, then the\n * percentages (saturation and luminance), finally, the alpha\n * channel. The values are then mapped to a color object for\n * manipulation/conversion.\n * @param {string} hslaString\n * @throws if missing HSL / alpha values\n * @returns {object} - parsed HSLA color object\n */\nvar parseHslaString = function parseHslaString(hslaString) {\n  // Deconstruct hsl string\n  var degPattern = '(360|3[0-5]\\\\d|[12]\\\\d{2}|[1-9]?\\\\d|\\\\d)(deg)?';\n  var turnPattern = '(1(\\\\.0+)?|0(\\\\.\\\\d+)?)';\n  var hue = hslaString.match(new RegExp('\\\\((' + degPattern + '|' + turnPattern + ')', 'g'));\n  var perc = hslaString.match(/[\\s,](100|[1-9]?\\d)%/g).map(function (s) {\n    return parseInt(s.slice(1, -1), 10) / 100;\n  });\n  var alpha = Number(hslaString.match(/(,|\\s)(1(\\.\\d+)?|0(\\.\\d+)?)\\)/)[0].slice(1, -1));\n  if (perc.length !== 2 || hue.length !== 1) throw new Error('Invalid HSL String');\n  // Normalize hue\n  if (/deg/.test(hue)) hue = hue[0].slice(1).replace('deg', '');else if (/turn/.test(hue)) hue = parseInt(hue[0].slice(1).replace('turn', ''), 10) * 360;else hue = hue[0].slice(1);\n  hue = parseInt(hue, 10);\n  var color = { h: hue, s: perc[0], l: perc[1], a: alpha };\n  // Return color object\n  return { color: color, format: 'string', type: 'hsla' };\n};\n\n/**\n * Parses hex string\n * Assumes format: `#[red][green][blue]`\n * \n * Deconstructs hex CSS string: getting all hex values (red, \n * green, blue) and parsing them as integers. The values are then\n * mapped to a color object for manipulation/conversion. \n * @param {string} hexString\n * @returns {object} - parsed RGB(hex) color object\n */\nvar parseHexString = function parseHexString(hexString) {\n  // deconstruct hex string\n  var hex = hexString.slice(1);\n  // normalize shorthand hex\n  hex = hex.length === 3 ? hex.split('').map(function (d) {\n    return d.repeat(2);\n  }).join('') : hex;\n  var color = {\n    r: parseInt(hex.slice(0, 2), 16),\n    g: parseInt(hex.slice(2, 4), 16),\n    b: parseInt(hex.slice(4, 6), 16)\n  };\n  // return color object\n  return { color: color, format: 'string', type: 'rgb', hex: true };\n};\n\n/**\n * Parses color string\n * Assumes CSS compatability and hue values are in degrees\n * \n * Matches the given CSS string with a given prefix and calls\n * the corresponding parser, returning the parsed color object\n * @param {string} colorString\n * @throws if color type not matched\n * @returns {object} - parsed [deffered] color object\n */\nvar parseColorString = function parseColorString(colorString) {\n  var color = void 0;\n  // determine type and defer to type parser\n  if (/^rgb\\s?\\(/.test(colorString)) color = parseRgbString(colorString);else if (/^rgba\\s?\\(/.test(colorString)) color = parseRgbaString(colorString);else if (/^hsl\\s?\\(/.test(colorString)) color = parseHslString(colorString);else if (/^hsla\\s?\\(/.test(colorString)) color = parseHslaString(colorString);else if (/^#[a-f0-9]{3,6}$/i.test(colorString)) color = parseHexString(colorString);else throw new Error('Unsupported color type');\n  return color;\n};\n\n/**\n * Parses color object\n * Assumes CSS compatability\n * \n * Matches the given color objects keys with a given format. The\n * color is then encapsulated in a parsed color object for \n * manipulation/conversion.\n * @param {object} colorString\n * @throws if color keys not matched\n * @returns {object} - parsed [type] color object\n */\nvar parseColorObject = function parseColorObject(colorObject) {\n  var keys = Object.keys(colorObject).map(function (c) {\n    return c.toLowerCase();\n  });\n  var type = void 0;\n  if ((0, _.equalArrays)(keys, 'rgb'.split(''))) type = 'rgb';else if ((0, _.equalArrays)(keys, 'rgba'.split(''))) type = 'rgba';else if ((0, _.equalArrays)(keys, 'hsl'.split(''))) type = 'hsl';else if ((0, _.equalArrays)(keys, 'hsla'.split(''))) type = 'hsla';else throw new Error('Unsupported color type');\n  return { color: colorObject, format: 'json', type: type };\n};\n\n/**\n * Parses color (reducer)\n * \n * Switches on color type and calls corresponding type\n * parser.\n * @param {string|object} color - color to convert\n * @throws color type not string or object\n * @returns {object} - referred parsed color\n * \n * @example Color string call stack\n * parseColor(`#fff`) =>\n *  parseColorString(`#fff`) =>\n *    parseHexColorString(`#fff`) \n * \n * @example Color object call stack\n * parseColor({ r: 255, g: 255, b: 255 }) =>\n *  parseColorObject({ r: 255, g: 255, b: 255 })\n */\nvar parseColor = function parseColor(color) {\n  var parsedColor = void 0;\n  switch (typeof color === 'undefined' ? 'undefined' : _typeof(color)) {\n    case 'string':\n      parsedColor = parseColorString(color);\n      break;\n    case 'object':\n      parsedColor = parseColorObject(color);\n      break;\n    default:\n      throw new Error('Unsupported color format');\n  }\n  return parsedColor;\n};\n\nexports.default = parseColor;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * HSL => HSL\n * \n * Deconstructs the HSL color object and formats the hsl\n * values to a HSL CSS string.\n * @param {object} hslColor\n * @returns {string} - HSL CSS string\n */\nvar toHsl = exports.toHsl = function toHsl(hslColor) {\n  var h = hslColor.h,\n      s = hslColor.s,\n      l = hslColor.l;\n\n  return 'hsl(' + h + ',' + s * 100 + '%,' + l * 100 + '%)';\n};\n\n/**\n * HSL => HSLA\n * \n * Returns result of previously defined toRgb function, changes\n * the prefix to `hsla` and adds a default alpha channel of 1.\n * @param {object} hslColor\n * @returns {string} - HSLA CSS string\n */\nvar toHsla = exports.toHsla = function toHsla(hslaColor) {\n  return 'hsla' + toHsl(hslaColor).slice(3, -1) + ',1)';\n};\n\n/**\n * HSL => RGB\n * \n * Deconstructs the HSL color object, calculates the chroma by\n * getting the absolute difference of the luminance (x2) - 1 *\n * saturation. The hue is divided by 60. A temporary component\n * (sec) is calculated by multiplying the chroma (percise) by the \n * absolute difference of 1 and the hue / 60 - 1. Now we can round\n * the hue divided. Switch on its value to assign the r,g,b percents.\n * The percents are then multiplied by 255 and rounded, to be formatted\n * to a RGB CSS string.\n * @todo make less ~ lossy\n * @param {object} hslColor\n * @returns {string} - RGB CSS string\n */\nvar toRgb = exports.toRgb = function toRgb(hslColor) {\n  var h = hslColor.h,\n      s = hslColor.s,\n      l = hslColor.l;\n\n  var red = void 0,\n      green = void 0,\n      blue = void 0;\n  var chroma = (1 - Math.abs(2 * l - 1)) * s;\n  var hueDiv = h / 60;\n  var sec = chroma * (1 - Math.abs(hueDiv % 2 - 1));\n  hueDiv = Math.round(hueDiv);\n  switch (hueDiv) {\n    case 0:\n      red = chroma;green = sec;blue = 0;\n      break;\n    case 1:\n      red = sec;green = chroma;blue = 0;\n      break;\n    case 2:\n      red = 0;green = chroma;blue = sec;\n      break;\n    case 3:\n      red = 0;green = sec;blue = chroma;\n      break;\n    case 4:\n      red = sec;green = 0;blue = chroma;\n      break;\n    case 5:\n      red = chroma;green = 0;blue = sec;\n      break;\n  }\n  return 'rgb(' + [red, green, blue].map(function (c) {\n    var adjColor = c + (l - chroma / 2);\n    return Math.round(adjColor * 255);\n  }).join(',') + ')';\n};\n\n/**\n * HSL => Hex\n * \n * For an indepth description, look at the HSL => RGB hex; the\n * only difference is the output. The rgb values are formatted\n * to a Hex CSS string.\n * @todo make less ~ lossy\n * @param {object} hslColor\n * @returns {string} - Hex CSS string\n */\nvar toHex = exports.toHex = function toHex(hslColor) {\n  var h = hslColor.h,\n      s = hslColor.s,\n      l = hslColor.l;\n\n  var red = void 0,\n      green = void 0,\n      blue = void 0;\n  var chroma = (1 - Math.abs(2 * l - 1)) * s;\n  var hueDiv = h / 60;\n  var sec = chroma * (1 - Math.abs(hueDiv % 2 - 1));\n  hueDiv = Math.round(hueDiv);\n  switch (hueDiv) {\n    case 0:\n      red = chroma;green = sec;blue = 0;\n      break;\n    case 1:\n      red = sec;green = chroma;blue = 0;\n      break;\n    case 2:\n      red = 0;green = chroma;blue = sec;\n      break;\n    case 3:\n      red = 0;green = sec;blue = chroma;\n      break;\n    case 4:\n      red = sec;green = 0;blue = chroma;\n      break;\n    case 5:\n      red = chroma;green = 0;blue = sec;\n      break;\n  }\n  return '#' + [red, green, blue].map(function (c) {\n    var adjColor = c + (l - chroma / 2);\n    var hex = Math.round(adjColor * 255).toString(16);\n    return hex.length === 2 ? hex : '0' + hex;\n  }).join('');\n};\n\n/**\n * HSL => RGBA\n * \n * Returns result of previously defined toRgb function, changes\n * the prefix to `rgba`, and adds a default alpha channel of 1.\n * @param {object} hslColor\n * @returns {string} - RGBA CSS string\n */\nvar toRgba = exports.toRgba = function toRgba(hslColor) {\n  return 'rgba' + toRgb(hslColor).slice(3, -1) + ',1)';\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * RGB => HSL\n * \n * Deconstructs the RGB color object and formats the values\n * to percents. The chroma value is calculated by subtracting the \n * min and max values. If the chroma/delta is 0, the hue and \n * saturation are 0 and the color is greyscale (exit early). Otherwise,\n * switch on the max value to calculate the hue. Finally, the values\n * are mapped to a HSL CSS string.\n * @param {object} rgbColor\n * @returns {string} - HSL CSS string\n */\nvar toHsl = exports.toHsl = function toHsl(rgbColor) {\n  var red = rgbColor.r / 255;\n  var green = rgbColor.g / 255;\n  var blue = rgbColor.b / 255;\n  var max = Math.max(red, green, blue);\n  var min = Math.min(red, green, blue);\n  var chroma = max - min;\n  var luminance = void 0,\n      saturation = void 0,\n      hue = void 0;\n  // Calculate luminance\n  luminance = (min + max) / 2;\n  // No further calculations needed; Achromatic\n  if (chroma === 0) return 'hsl(0,0%,' + parseInt(luminance * 100, 10) + '%)';\n  // Calculate saturation\n  saturation = luminance > 0.5 ? chroma / (2.0 - max - min) : chroma / (max + min);\n  // Calculate hue\n  switch (max) {\n    case red:\n      hue = ((green - blue) / chroma + (green < blue ? 6 : 0)) * 60;break;\n    case green:\n      hue = ((blue - red) / chroma + 2) * 60;break;\n    case blue:\n      hue = ((red - green) / chroma + 4) * 60;break;\n  }\n  hue = Math.round(hue);\n  saturation = Math.round(saturation * 100);\n  luminance = Math.round(luminance * 100);\n  return 'hsl(' + hue + ',' + saturation + '%,' + luminance + '%)';\n};\n\n/**\n * RGB => HSLA\n * \n * Returns result of previously declared toHsl function, changes\n * the prefix to `hsla` and appends a default alpha channel of 1.\n * @param {object} rgbColor\n * @returns {string} - HSLA CSS string\n */\nvar toHsla = exports.toHsla = function toHsla(rgbColor) {\n  return 'hsla' + toHsl(rgbColor).slice(3, -1) + ',1)';\n};\n\n/**\n * RGB => Hex\n * \n * Deconstructs RGB color object and maps its values to a Hex\n * CSS string format.\n * @param {object} rgbColor\n * @returns {string} - Hex CSS string\n */\nvar toHex = exports.toHex = function toHex(rgbColor) {\n  var r = rgbColor.r,\n      g = rgbColor.g,\n      b = rgbColor.b;\n\n  return '#' + [r, g, b].map(function (n) {\n    var num = n.toString(16);\n    return num.length === 2 ? num : '0' + num;\n  }).join('');\n};\n\n/**\n * RGB => RGB\n * \n * Deconstructs RGB color object and maps its values to a RGB\n * CSS string format.\n * @param {object} rgbColor\n * @return {string} - RGB CSS string\n */\nvar toRgb = exports.toRgb = function toRgb(rgbColor) {\n  var r = rgbColor.r,\n      g = rgbColor.g,\n      b = rgbColor.b;\n\n  return 'rgb(' + r + ',' + g + ',' + b + ')';\n};\n\n/**\n * RGB => RGBA\n * \n * Returns result of previously declared toRgb function, changes\n * the prefix to `rgba` and appends a default alpha channel of 1.\n * @param {object} rgbColor\n * @return {string} - RGBA CSS string\n */\nvar toRgba = exports.toRgba = function toRgba(rgbColor) {\n  return 'rgba' + toRgb(rgbColor).slice(3, -1) + ',1)';\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _conversions = __webpack_require__(1);\n\nObject.defineProperty(exports, 'toHsl', {\n  enumerable: true,\n  get: function get() {\n    return _conversions.toHsl;\n  }\n});\nObject.defineProperty(exports, 'toHsla', {\n  enumerable: true,\n  get: function get() {\n    return _conversions.toHsla;\n  }\n});\nObject.defineProperty(exports, 'toHex', {\n  enumerable: true,\n  get: function get() {\n    return _conversions.toHex;\n  }\n});\nObject.defineProperty(exports, 'toRgb', {\n  enumerable: true,\n  get: function get() {\n    return _conversions.toRgb;\n  }\n});\nObject.defineProperty(exports, 'toRgba', {\n  enumerable: true,\n  get: function get() {\n    return _conversions.toRgba;\n  }\n});\n\nvar _manipulations = __webpack_require__(10);\n\nObject.defineProperty(exports, 'darken', {\n  enumerable: true,\n  get: function get() {\n    return _manipulations.darken;\n  }\n});\nObject.defineProperty(exports, 'lighten', {\n  enumerable: true,\n  get: function get() {\n    return _manipulations.lighten;\n  }\n});\nObject.defineProperty(exports, 'saturate', {\n  enumerable: true,\n  get: function get() {\n    return _manipulations.saturate;\n  }\n});\nObject.defineProperty(exports, 'desaturate', {\n  enumerable: true,\n  get: function get() {\n    return _manipulations.desaturate;\n  }\n});\nObject.defineProperty(exports, 'opacify', {\n  enumerable: true,\n  get: function get() {\n    return _manipulations.opacify;\n  }\n});\nObject.defineProperty(exports, 'transparentize', {\n  enumerable: true,\n  get: function get() {\n    return _manipulations.transparentize;\n  }\n});\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Determines if two arrays are equal\n * \n * @param {array} arr1 \n * @param {array} arr2\n */\nvar equalsArray = function equalsArray(arr1, arr2) {\n  if (arr1 === arr2) return true;\n  if (arr1 == null || arr2 == null) return false;\n  if (arr1.length !== arr2.length) return false;\n  // sort arrays\n  var a = arr1.sort();\n  var b = arr2.sort();\n  for (var i = 0; i < arr1.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n};\n\nexports.default = equalsArray;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _utils = __webpack_require__(0);\n\nvar _conversions = __webpack_require__(1);\n\nvar convert = _interopRequireWildcard(_conversions);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Convenience toHsla method\n * \n * Parses a given color, determines it's type, converts\n * it to HSLA if it is not HSLA already. Finally It returns\n * the color and a handy closure that returns the color back\n * to it's original type.\n */\nvar convenienceToHsla = function convenienceToHsla($color) {\n  var parsed = (0, _utils.parseColor)($color);\n  var subScript = 'to' + parsed.type[0].toUpperCase() + parsed.type.slice(1);\n  var color = subScript.includes('Hsla') ? parsed.color : convert.toJSON(convert.toHsla($color));\n  var toOriginalColorType = function toOriginalColorType(newColor) {\n    return convert[subScript](newColor);\n  };\n  return { color: color, toOriginalColorType: toOriginalColorType };\n};\n\nexports.default = convenienceToHsla;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toRgba = exports.toRgb = exports.toHex = exports.toHsla = exports.toHsl = undefined;\n\nvar _hsl = __webpack_require__(3);\n\nvar hsl = _interopRequireWildcard(_hsl);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * HSL => HSL\n * \n * Returns the result of hsl.toHsl, as the alpha channel is \n * irrelavent.\n * @param {object} hslColor\n * @returns {string} - HSL CSS string\n */\nvar toHsl = exports.toHsl = function toHsl(hslaColor) {\n  return hsl.toHsl(hslaColor);\n};\n\n/**\n * HSL => HSLA\n * \n * Returns the result of hsl.toHsl, changes prefix to hsla and\n * appends the hslaColor's alpha channel.\n * @param {object} hslColor\n * @returns {string} - HSLA CSS string\n */\nvar toHsla = exports.toHsla = function toHsla(hslaColor) {\n  var a = hslaColor.a;\n\n  return 'hsla' + hsl.toHsl(hslaColor).slice(3, -1) + ',' + a + ')';\n};\n\n/**\n * HSL => Hex\n * \n * Returns the result of hsl.toHex, as the alpha channel is \n * irrelavent.\n * @param {object} hslColor\n * @returns {string} - Hex CSS string\n */\nvar toHex = exports.toHex = function toHex(hslaColor) {\n  return hsl.toHex(hslaColor);\n};\n\n/**\n * HSL => RGB\n * \n * Returns the result of hsl.toRgb, as the alpha channel is \n * irrelavent.\n * @param {object} hslaColor\n * @returns {string} - RGB CSS string\n */\nvar toRgb = exports.toRgb = function toRgb(hslaColor) {\n  return hsl.toRgb(hslaColor);\n};\n\n/**\n * HSL => RGBA\n * \n * Returns the result of hsl.toRgb, changes prefix to rgba and\n * appends the hslaColor's alpha channel.\n * @param {object} hslColor\n * @returns {string} - RGBA CSS string\n */\nvar toRgba = exports.toRgba = function toRgba(hslaColor) {\n  var a = hslaColor.a;\n\n  return 'rgba' + hsl.toRgb(hslaColor).slice(3, -1) + ',' + a + ')';\n};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toRgba = exports.toRgb = exports.toHex = exports.toHsla = exports.toHsl = undefined;\n\nvar _rgb = __webpack_require__(4);\n\nvar rgb = _interopRequireWildcard(_rgb);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * RGBA => HSL\n * \n * Calls rgb.toHsl method as the alpha channel is irrelavent.\n * @param {object} rgbaColor\n * @returns {string} - HSL CSS string\n */\nvar toHsl = exports.toHsl = function toHsl(rgbaColor) {\n  return rgb.toHsl(rgbaColor);\n};\n\n/**\n * RGBA => HSLA\n * \n * Returns the result of rgb.toHsl, changes prefix to hsla and \n * appends the rgbaColor's alpha channel.\n * @param {object} rgbaColor\n * @returns {string} - HSLA CSS string\n */\nvar toHsla = exports.toHsla = function toHsla(rgbaColor) {\n  var a = rgbaColor.a;\n\n  return 'hsla' + rgb.toHsl(rgbaColor).slice(3, -1) + ',' + a + ')';\n};\n\n/**\n * RGBA => Hex\n * \n * Calls rgb.toHex method as the alpha channel is irrelavent.\n * @param {object} rgbaColor\n * @returns {string} - Hex CSS string\n */\nvar toHex = exports.toHex = function toHex(rgbaColor) {\n  return rgb.toHex(rgbaColor);\n};\n\n/**\n * RGBA -> RGB\n * \n * Calls rgb.toRgb method as the alpha channel is irrelavent.\n * @param {object} rgbaColor\n * @returns {string} - RGB CSS string\n */\nvar toRgb = exports.toRgb = function toRgb(rgbaColor) {\n  return rgb.toRgb(rgbaColor);\n};\n\n/**\n *  RGBA => RGBA\n * \n * Returns the result of rgb.toHsl, changes prefix to rgba and\n * appends the rgbaColor's alpha channel.\n * @param {object} rgbaColor\n * @returns {string} - RGBA CSS string\n */\nvar toRgba = exports.toRgba = function toRgba(rgbaColor) {\n  var a = rgbaColor.a;\n\n  return 'rgba' + rgb.toRgba(rgbaColor).slice(3, -1) + ',' + a + ')';\n};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _luminance = __webpack_require__(11);\n\nObject.defineProperty(exports, 'lighten', {\n  enumerable: true,\n  get: function get() {\n    return _luminance.lighten;\n  }\n});\nObject.defineProperty(exports, 'darken', {\n  enumerable: true,\n  get: function get() {\n    return _luminance.darken;\n  }\n});\n\nvar _saturation = __webpack_require__(12);\n\nObject.defineProperty(exports, 'saturate', {\n  enumerable: true,\n  get: function get() {\n    return _saturation.saturate;\n  }\n});\nObject.defineProperty(exports, 'desaturate', {\n  enumerable: true,\n  get: function get() {\n    return _saturation.desaturate;\n  }\n});\n\nvar _opacity = __webpack_require__(13);\n\nObject.defineProperty(exports, 'opacify', {\n  enumerable: true,\n  get: function get() {\n    return _opacity.opacify;\n  }\n});\nObject.defineProperty(exports, 'transparentize', {\n  enumerable: true,\n  get: function get() {\n    return _opacity.transparentize;\n  }\n});\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.darken = exports.lighten = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _utils = __webpack_require__(0);\n\n/**\n * Alters color's luminance value\n * \n * Parses color, converts it to HSLA (for easy manipulation),\n * reduces/increases the luminance value according to the factor\n * if possible. Finally, it is converted to it's original format \n * and returned via a convenience closure.\n * @param {string|object} $color \n * @param {number} factor\n * @returns {string} - [type] CSS string\n */\nvar alterLuminance = function alterLuminance($color, factor) {\n  if (factor > 1 || factor < -1) throw new Error('Invalid factor');\n\n  var _convenienceToHsla = (0, _utils.convenienceToHsla)($color),\n      color = _convenienceToHsla.color,\n      toOriginalColorType = _convenienceToHsla.toOriginalColorType;\n\n  var lum = color.l;\n  var adjLum = lum + factor;\n  // keep luminance bound to range of [0 - 1]\n  if (adjLum <= 1 && adjLum >= 0) lum = adjLum;else {\n    console.warn('lum out of bounds');lum = adjLum > 0.5 ? 1 : 0;\n  }\n  return toOriginalColorType(_extends({}, color, { l: lum }));\n};\n\n/**\n * Lightens color\n * \n * Calls alterLuminance function with a positive factor, making\n * the luminance value increase. \n * @param {string|object} color\n * @param {number} factor \n */\nvar lighten = exports.lighten = function lighten(color) {\n  var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n  return alterLuminance(color, factor);\n};\n\n/**\n * Darkens color\n * \n * Calls alterLuminance function with a negitive factor, making\n * the luminance value decrease.\n * @param {string|object} color\n * @param {number} factor \n */\nvar darken = exports.darken = function darken(color) {\n  var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n  return alterLuminance(color, -factor);\n};\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.desaturate = exports.saturate = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _utils = __webpack_require__(0);\n\n/**\n * Alters color's saturation value\n * \n * Parses color, converts it to HSLA (for easy manipulation),\n * reduces/increases the saturation value according to the factor\n * if possible. Finally, it is converted to it's original format \n * and returned via a convenience closure.\n * @param {string|object} $color \n * @param {number} factor\n * @returns {string} - [type] CSS string\n */\nvar alterSaturation = function alterSaturation($color, factor) {\n  if (factor > 1 || factor < -1) throw new Error('Invalid factor');\n\n  var _convenienceToHsla = (0, _utils.convenienceToHsla)($color),\n      color = _convenienceToHsla.color,\n      toOriginalColorType = _convenienceToHsla.toOriginalColorType;\n\n  var sat = color.s;\n  var adjSat = sat + factor;\n  // keep saturation bound to range of [0 - 1]\n  if (adjSat <= 1 && adjSat >= 0) sat = adjSat;else {\n    console.warn('sat out of bounds');sat = adjSat > 0.5 ? 1 : 0;\n  }\n  return toOriginalColorType(_extends({}, color, { s: sat }));\n};\n\n/**\n * Saturates color\n * \n * Calls alterSaturation function with a positive factor, making\n * the saturation value increase by the factor.\n * @param {string|object} color\n * @param {number} factor\n * @returns {string} - [type] CSS string\n */\nvar saturate = exports.saturate = function saturate(color) {\n  var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n  return alterSaturation(color, factor);\n};\n\n/**\n * Desaturates color\n * \n * Calls alterSaturation function with a negative factor, making\n * the saturation value decrease by the factor.\n * @param {string|object} color \n * @param {number} factor \n * @returns {string} - [type] CSS string\n */\nvar desaturate = exports.desaturate = function desaturate(color) {\n  var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n  return alterSaturation(color, -factor);\n};\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transparentize = exports.opacify = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _utils = __webpack_require__(0);\n\n/**\n * Alters color's alpha chanel\n * \n * Parses color, converts it to HSLA (for easy manipulation),\n * reduces/increases the alpha channel according to the factor\n * if possible. Finally, it is converted to it's original format \n * and returned via a convenience closure.\n * @param {string|object} $color \n * @param {number} factor\n * @returns {string} - [type] CSS string\n */\nvar alterOpacity = function alterOpacity($color, factor) {\n  if (factor > 1 || factor < -1) throw new Error('Invalid factor');\n\n  var _convenienceToHsla = (0, _utils.convenienceToHsla)($color),\n      color = _convenienceToHsla.color,\n      toOriginalColorType = _convenienceToHsla.toOriginalColorType;\n\n  var alpha = color.a;\n  var adjAlpha = alpha + factor;\n  // keep alpha channel bound to range of [0 - 1]\n  if (adjAlpha <= 1 && adjAlpha >= 0) alpha = adjAlpha;else {\n    console.warn('alpha out of bounds');alpha = adjAlpha > 0.5 ? 1 : 0;\n  }\n  return toOriginalColorType(_extends({}, color, { a: alpha }));\n};\n\n/**\n * Opacifies color\n * \n * Calls alterOpacity function with a positive factor, making\n * the alpha channel increase by the factor.\n * @param {*}  \n * @param {*} factor \n */\nvar opacify = exports.opacify = function opacify(color) {\n  var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n  return alterOpacity(color, factor);\n};\n\n/**\n * Transparentizes color\n * \n * Calls alterOpacity function with a negative factor, making\n * the alpha channel decrease by the factor.\n * @param {*} color \n * @param {*} factor \n */\nvar transparentize = exports.transparentize = function transparentize(color) {\n  var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n  return alterOpacity(color, -factor);\n};\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// colornary.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1b22cb9abb7bed57f47a","export { default as parseColor } from './parse-color';\nexport { default as equalArrays } from './equal-arrays';\nexport { default as convenienceToHsla } from './convenience-to-hsla';\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/index.js","import parseColor from '../utils/parse-color';\nimport * as hsl from './hsl';\nimport * as hsla from './hsla';\nimport * as rgb from './rgb';\nimport * as rgba from './rgba';\n\n\nconst conversions = {\n  hsl,\n  hsla,\n  rgb,\n  rgba,\n};\n\n\n/**\n * Converts color to Hsl\n * \n * @param {string|object} $color\n * @return {string} - Hsl string  \n */\nexport const toHsl = ($color) => {\n  let hslColor;\n  try {\n    const colorObject = parseColor($color);\n    const { type, color } = colorObject;\n    hslColor = conversions[type].toHsl(color);\n  } catch (err) {\n    console.error(err);\n  }\n  return hslColor;\n};\n\n\n/**\n * Converts color to Hsla\n * \n * @param {string|object} $color\n * @return {string} - Hsla string  \n */\nexport const toHsla = ($color) => {\n  let hslaColor;\n  try {\n    const colorObject = parseColor($color);\n    const { type, color } = colorObject;\n    hslaColor = conversions[type].toHsla(color);\n  } catch (err) {\n    console.error(err);\n  }\n  return hslaColor;\n};\n\n\n/**\n * Converts color to Hex\n * \n * @param {string|object} $color\n * @returns {string} - Hex string\n */\nexport const toHex = ($color) => {\n  let hexColor;\n  try {\n    const colorObject = parseColor($color);\n    const { type, color } = colorObject;\n    hexColor = conversions[type].toHex(color);\n  } catch (err) {\n    console.error(err);\n  }\n  return hexColor;\n};\n\n\n/**\n * Converts color to RGB\n * \n * @param {string|object} $color\n * @returns {string} - RGB CSS string\n */\nexport const toRgb = ($color) => {\n  let rgbColor;\n  try {\n    const colorObject = parseColor($color);\n    const { type, color } = colorObject;\n    rgbColor = conversions[type].toRgb(color);\n  } catch (err) {\n    console.error(err);\n  }\n  return rgbColor;\n};\n\n\n/**\n * Converts color to RGBA\n * \n * @param {string|object} $color\n * @returns {string} - RGBA CSS string\n */\nexport const toRgba = ($color) => {\n  let rgbaColor;\n  try {\n    const colorObject = parseColor($color);\n    const { type, color } = colorObject;\n    rgbaColor = conversions[type].toRgba(color);\n  } catch (err) {\n    console.error(err);\n  }\n  return rgbaColor;\n};\n\n\n/**\n * Converts color to JSON\n * \n * @param {string|object} $color\n * @returns {object} - Color JSON\n */\nexport const toJSON = (color) => {\n  let jsonColor;\n  try {\n    jsonColor = parseColor(color).color;\n  } catch (err) {\n    console.error(err);\n  }\n  return jsonColor;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/conversions/index.js","import { equalArrays } from './';\n\n\n/**\n * Parses RGB string\n * Assumes format `rgb([red], [green], [blue])`\n * \n * Deconstructs RGB CSS string: gets all three, 0-255 values\n * (red, green, blue). The values are then mapped to a color\n * object for manipulation/conversion.\n * @param {string} rgbString\n * @throws if missing rgb values\n * @returns {object} - parsed RGB color object\n */\nconst parseRgbString = (rgbString) => {\n  // deconstruct rgb\n  const values = rgbString.match(/(2[0-5]\\d|1\\d{2}|\\d{1,2})/g)\n    .map(n => parseInt(n, 10));\n  if (values.length !== 3) throw new Error('Invalid RGB String');\n  const color = { r: values[0], g: values[1], b: values[2] };\n  // return color object\n  return { color, format: 'string', type: 'rgb' };\n};\n\n\n/**\n * Parses RGBA string\n * Assumes format: `rgba([red], [green], [blue], [alpha])`\n * \n * Deconstructs RGBA CSS string: first getting all three, 0-255\n * values (red, green, blue), then the alpha channel. The values\n * are then mapped to a color object for manipulation/conversion.\n * @param {string} rgbaString\n * @throws if missing RGB / alpha values\n * @returns {object} - parsed RGB color object\n */\nconst parseRgbaString = (rgbaString) => {\n  // deconstruct rgba string\n  const values = rgbaString.match(/(2[0-5]\\d|1\\d{2}|\\d{1,2}),/g)\n    .map(s => parseInt(s.slice(0, -1), 10));\n  if (values.length !== 3) throw new Error('Invalid RGBA String');\n  const alpha = parseFloat(rgbaString.match(/(1(\\.0)?|0(\\.\\d+)?)\\)/)[0].slice(0, -1));\n  const color = { r: values[0], g: values[1], b: values[2], a: alpha };\n  // return color object\n  return { color, format: 'string', type: 'rgba' };\n};\n\n\n/**\n * Parses HSL string\n * Assumes format: `hsl([hue], [saturation], [luminance])`\n * \n * Deconstructs HSL CSS string: first getting the hue, then the\n * percentages (saturation and luminance). The values are then\n * mapped to a color object for manipulation/conversion.\n * @param {string} hslString\n * @throws if missing HSL values\n * @returns {object} - parsed HSL color object\n */\nconst parseHslString = (hslString) => {\n  // Deconstruct hsl string\n  const degPattern = '(360|3[0-5]\\\\d|[12]\\\\d{2}|[1-9]?\\\\d|\\\\d)(deg)?';\n  const turnPattern = '(1(\\\\.0+)?|0(\\\\.\\\\d+)?)';\n  let hue = hslString.match(new RegExp(`\\\\((${degPattern}|${turnPattern})`, 'g'));\n  const perc = hslString.match(/[\\s,](100|[1-9]?\\d)%/g).map(s => parseInt(s.slice(1, -1), 10) / 100);\n  if (perc.length !== 2 || hue.length !== 1) throw new Error('Invalid HSL String');\n  // Normalize hue\n  if (/deg/.test(hue)) hue = hue[0].slice(1).replace('deg', '');\n  else if (/turn/.test(hue)) hue = parseInt(hue[0].slice(1).replace('turn', ''), 10) * 360;\n  else hue = hue[0].slice(1);\n  hue = parseInt(hue, 10);\n  const color = { h: hue, s: perc[0], l: perc[1] };\n  // Return color object\n  return { color, format: 'string', type: 'hsl' };\n};\n\n\n/**\n * Parses HSLA string\n * Assumes format: `hsla([hue], [saturation], [luminance], [alpha])`\n * \n * Deconstructs HSLA CSS string: first getting the hue, then the\n * percentages (saturation and luminance), finally, the alpha\n * channel. The values are then mapped to a color object for\n * manipulation/conversion.\n * @param {string} hslaString\n * @throws if missing HSL / alpha values\n * @returns {object} - parsed HSLA color object\n */\nconst parseHslaString = (hslaString) => {\n  // Deconstruct hsl string\n  const degPattern = '(360|3[0-5]\\\\d|[12]\\\\d{2}|[1-9]?\\\\d|\\\\d)(deg)?';\n  const turnPattern = '(1(\\\\.0+)?|0(\\\\.\\\\d+)?)';\n  let hue = hslaString.match(new RegExp(`\\\\((${degPattern}|${turnPattern})`, 'g'));\n  const perc = hslaString.match(/[\\s,](100|[1-9]?\\d)%/g).map(s => parseInt(s.slice(1, -1), 10) / 100);\n  const alpha = Number(hslaString.match(/(,|\\s)(1(\\.\\d+)?|0(\\.\\d+)?)\\)/)[0].slice(1, -1));\n  if (perc.length !== 2 || hue.length !== 1) throw new Error('Invalid HSL String');\n  // Normalize hue\n  if (/deg/.test(hue)) hue = hue[0].slice(1).replace('deg', '');\n  else if (/turn/.test(hue)) hue = parseInt(hue[0].slice(1).replace('turn', ''), 10) * 360;\n  else hue = hue[0].slice(1);\n  hue = parseInt(hue, 10);\n  const color = { h: hue, s: perc[0], l: perc[1], a: alpha };\n  // Return color object\n  return { color, format: 'string', type: 'hsla' };\n};\n\n\n/**\n * Parses hex string\n * Assumes format: `#[red][green][blue]`\n * \n * Deconstructs hex CSS string: getting all hex values (red, \n * green, blue) and parsing them as integers. The values are then\n * mapped to a color object for manipulation/conversion. \n * @param {string} hexString\n * @returns {object} - parsed RGB(hex) color object\n */\nconst parseHexString = (hexString) => {\n  // deconstruct hex string\n  let hex = hexString.slice(1);\n  // normalize shorthand hex\n  hex = hex.length === 3 ? hex.split('').map(d => d.repeat(2)).join('') : hex;\n  const color = {\n    r: parseInt(hex.slice(0, 2), 16),\n    g: parseInt(hex.slice(2, 4), 16),\n    b: parseInt(hex.slice(4, 6), 16),\n  };\n  // return color object\n  return { color, format: 'string', type: 'rgb', hex: true };\n};\n\n\n/**\n * Parses color string\n * Assumes CSS compatability and hue values are in degrees\n * \n * Matches the given CSS string with a given prefix and calls\n * the corresponding parser, returning the parsed color object\n * @param {string} colorString\n * @throws if color type not matched\n * @returns {object} - parsed [deffered] color object\n */\nconst parseColorString = (colorString) => {\n  let color;\n  // determine type and defer to type parser\n  if (/^rgb\\s?\\(/.test(colorString)) color = parseRgbString(colorString);\n  else if (/^rgba\\s?\\(/.test(colorString)) color = parseRgbaString(colorString);\n  else if (/^hsl\\s?\\(/.test(colorString)) color = parseHslString(colorString);\n  else if (/^hsla\\s?\\(/.test(colorString)) color = parseHslaString(colorString);\n  else if (/^#[a-f0-9]{3,6}$/i.test(colorString)) color = parseHexString(colorString);\n  else throw new Error('Unsupported color type');\n  return color;\n};\n\n\n/**\n * Parses color object\n * Assumes CSS compatability\n * \n * Matches the given color objects keys with a given format. The\n * color is then encapsulated in a parsed color object for \n * manipulation/conversion.\n * @param {object} colorString\n * @throws if color keys not matched\n * @returns {object} - parsed [type] color object\n */\nconst parseColorObject = (colorObject) => {\n  const keys = Object.keys(colorObject).map(c => c.toLowerCase());\n  let type;\n  if (equalArrays(keys, 'rgb'.split(''))) type = 'rgb';\n  else if (equalArrays(keys, 'rgba'.split(''))) type = 'rgba';\n  else if (equalArrays(keys, 'hsl'.split(''))) type = 'hsl';\n  else if (equalArrays(keys, 'hsla'.split(''))) type = 'hsla';\n  else throw new Error('Unsupported color type');\n  return { color: colorObject, format: 'json', type };\n};\n\n\n/**\n * Parses color (reducer)\n * \n * Switches on color type and calls corresponding type\n * parser.\n * @param {string|object} color - color to convert\n * @throws color type not string or object\n * @returns {object} - referred parsed color\n * \n * @example Color string call stack\n * parseColor(`#fff`) =>\n *  parseColorString(`#fff`) =>\n *    parseHexColorString(`#fff`) \n * \n * @example Color object call stack\n * parseColor({ r: 255, g: 255, b: 255 }) =>\n *  parseColorObject({ r: 255, g: 255, b: 255 })\n */\nconst parseColor = (color) => {\n  let parsedColor;\n  switch (typeof color) {\n    case 'string':\n      parsedColor = parseColorString(color);\n      break;\n    case 'object':\n      parsedColor = parseColorObject(color);\n      break;\n    default:\n      throw new Error('Unsupported color format');\n  }\n  return parsedColor;\n};\n\n\nexport default parseColor;\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/parse-color.js","/**\n * HSL => HSL\n * \n * Deconstructs the HSL color object and formats the hsl\n * values to a HSL CSS string.\n * @param {object} hslColor\n * @returns {string} - HSL CSS string\n */\nexport const toHsl = (hslColor) => {\n  const { h, s, l } = hslColor;\n  return `hsl(${h},${s * 100}%,${l * 100}%)`;\n};\n\n\n/**\n * HSL => HSLA\n * \n * Returns result of previously defined toRgb function, changes\n * the prefix to `hsla` and adds a default alpha channel of 1.\n * @param {object} hslColor\n * @returns {string} - HSLA CSS string\n */\nexport const toHsla = hslaColor => `hsla${toHsl(hslaColor).slice(3, -1)},1)`;\n\n\n/**\n * HSL => RGB\n * \n * Deconstructs the HSL color object, calculates the chroma by\n * getting the absolute difference of the luminance (x2) - 1 *\n * saturation. The hue is divided by 60. A temporary component\n * (sec) is calculated by multiplying the chroma (percise) by the \n * absolute difference of 1 and the hue / 60 - 1. Now we can round\n * the hue divided. Switch on its value to assign the r,g,b percents.\n * The percents are then multiplied by 255 and rounded, to be formatted\n * to a RGB CSS string.\n * @todo make less ~ lossy\n * @param {object} hslColor\n * @returns {string} - RGB CSS string\n */\nexport const toRgb = (hslColor) => {\n  const { h, s, l } = hslColor;\n  let red, green, blue;\n  const chroma = (1 - Math.abs((2 * l) - 1)) * s;\n  let hueDiv = h / 60;\n  const sec = chroma * (1 - Math.abs((hueDiv % 2) - 1));\n  hueDiv = Math.round(hueDiv);\n  switch (hueDiv) {\n    case 0:\n      red = chroma; green = sec; blue = 0;\n      break;\n    case 1:\n      red = sec; green = chroma; blue = 0;\n      break;\n    case 2:\n      red = 0; green = chroma; blue = sec;\n      break;\n    case 3:\n      red = 0; green = sec; blue = chroma;\n      break;\n    case 4:\n      red = sec; green = 0; blue = chroma;\n      break;\n    case 5:\n      red = chroma; green = 0; blue = sec;\n      break;\n  }\n  return `rgb(${[red, green, blue].map((c) => {\n    const adjColor = c + (l - (chroma / 2));\n    return Math.round(adjColor * 255);\n  }).join(',')})`;\n};\n\n\n/**\n * HSL => Hex\n * \n * For an indepth description, look at the HSL => RGB hex; the\n * only difference is the output. The rgb values are formatted\n * to a Hex CSS string.\n * @todo make less ~ lossy\n * @param {object} hslColor\n * @returns {string} - Hex CSS string\n */\nexport const toHex = (hslColor) => {\n  const { h, s, l } = hslColor;\n  let red, green, blue;\n  const chroma = (1 - Math.abs((2 * l) - 1)) * s;\n  let hueDiv = h / 60;\n  const sec = chroma * (1 - Math.abs((hueDiv % 2) - 1));\n  hueDiv = Math.round(hueDiv);\n  switch (hueDiv) {\n    case 0:\n      red = chroma; green = sec; blue = 0;\n      break;\n    case 1:\n      red = sec; green = chroma; blue = 0;\n      break;\n    case 2:\n      red = 0; green = chroma; blue = sec;\n      break;\n    case 3:\n      red = 0; green = sec; blue = chroma;\n      break;\n    case 4:\n      red = sec; green = 0; blue = chroma;\n      break;\n    case 5:\n      red = chroma; green = 0; blue = sec;\n      break;\n  }\n  return `#${[red, green, blue].map((c) => {\n    const adjColor = c + (l - (chroma / 2));\n    const hex = Math.round(adjColor * 255).toString(16);\n    return hex.length === 2 ? hex : `0${hex}`;\n  }).join('')}`;\n};\n\n\n/**\n * HSL => RGBA\n * \n * Returns result of previously defined toRgb function, changes\n * the prefix to `rgba`, and adds a default alpha channel of 1.\n * @param {object} hslColor\n * @returns {string} - RGBA CSS string\n */\nexport const toRgba = hslColor => `rgba${toRgb(hslColor).slice(3, -1)},1)`;\n\n\n\n// WEBPACK FOOTER //\n// ./src/conversions/hsl.js","/**\n * RGB => HSL\n * \n * Deconstructs the RGB color object and formats the values\n * to percents. The chroma value is calculated by subtracting the \n * min and max values. If the chroma/delta is 0, the hue and \n * saturation are 0 and the color is greyscale (exit early). Otherwise,\n * switch on the max value to calculate the hue. Finally, the values\n * are mapped to a HSL CSS string.\n * @param {object} rgbColor\n * @returns {string} - HSL CSS string\n */\nexport const toHsl = (rgbColor) => {\n  const red = rgbColor.r / 255;\n  const green = rgbColor.g / 255;\n  const blue = rgbColor.b / 255;\n  const max = Math.max(red, green, blue);\n  const min = Math.min(red, green, blue);\n  const chroma = max - min;\n  let luminance, saturation, hue;\n  // Calculate luminance\n  luminance = (min + max) / 2;\n  // No further calculations needed; Achromatic\n  if (chroma === 0) return `hsl(0,0%,${parseInt(luminance * 100, 10)}%)`;\n  // Calculate saturation\n  saturation = luminance > 0.5 ?\n    chroma / (2.0 - max - min) :\n    chroma / (max + min);\n  // Calculate hue\n  switch (max) {\n    case red:\n      hue = ((green - blue) / chroma + (green < blue ? 6 : 0)) * 60; break;\n    case green:\n      hue = ((blue - red) / chroma + 2) * 60; break;\n    case blue:\n      hue = ((red - green) / chroma + 4) * 60; break;\n  }\n  hue = Math.round(hue);\n  saturation = Math.round(saturation * 100);\n  luminance = Math.round(luminance * 100);\n  return `hsl(${hue},${saturation}%,${luminance}%)`;\n};\n\n\n/**\n * RGB => HSLA\n * \n * Returns result of previously declared toHsl function, changes\n * the prefix to `hsla` and appends a default alpha channel of 1.\n * @param {object} rgbColor\n * @returns {string} - HSLA CSS string\n */\nexport const toHsla = rgbColor => `hsla${toHsl(rgbColor).slice(3, -1)},1)`;\n\n\n/**\n * RGB => Hex\n * \n * Deconstructs RGB color object and maps its values to a Hex\n * CSS string format.\n * @param {object} rgbColor\n * @returns {string} - Hex CSS string\n */\nexport const toHex = (rgbColor) => {\n  const { r, g, b } = rgbColor;\n  return `#${[r, g, b].map((n) => {\n    const num = n.toString(16);\n    return num.length === 2 ? num : `0${num}`;\n  }).join('')}`;\n};\n\n\n/**\n * RGB => RGB\n * \n * Deconstructs RGB color object and maps its values to a RGB\n * CSS string format.\n * @param {object} rgbColor\n * @return {string} - RGB CSS string\n */\nexport const toRgb = (rgbColor) => {\n  const { r, g, b } = rgbColor;\n  return `rgb(${r},${g},${b})`;\n};\n\n\n/**\n * RGB => RGBA\n * \n * Returns result of previously declared toRgb function, changes\n * the prefix to `rgba` and appends a default alpha channel of 1.\n * @param {object} rgbColor\n * @return {string} - RGBA CSS string\n */\nexport const toRgba = rgbColor => `rgba${toRgb(rgbColor).slice(3, -1)},1)`;\n\n\n\n// WEBPACK FOOTER //\n// ./src/conversions/rgb.js","/* eslint-disable */\nexport {\n  toHsl,\n  toHsla,\n  toHex,\n  toRgb,\n  toRgba,\n} from './conversions';\n\nexport {\n  darken,\n  lighten,\n  saturate,\n  desaturate,\n  opacify,\n  transparentize,\n} from './manipulations';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/**\n * Determines if two arrays are equal\n * \n * @param {array} arr1 \n * @param {array} arr2\n */\nconst equalsArray = (arr1, arr2) => {\n  if (arr1 === arr2) return true;\n  if (arr1 == null || arr2 == null) return false;\n  if (arr1.length !== arr2.length) return false;\n  // sort arrays\n  const a = arr1.sort();\n  const b = arr2.sort();\n  for (let i = 0; i < arr1.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n};\n\n\nexport default equalsArray;\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/equal-arrays.js","import { parseColor } from '../utils';\nimport * as convert from '../conversions';\n\n\n/**\n * Convenience toHsla method\n * \n * Parses a given color, determines it's type, converts\n * it to HSLA if it is not HSLA already. Finally It returns\n * the color and a handy closure that returns the color back\n * to it's original type.\n */\nconst convenienceToHsla = ($color) => {\n  const parsed = parseColor($color);\n  const subScript = `to${parsed.type[0].toUpperCase()}${parsed.type.slice(1)}`;\n  const color = subScript.includes('Hsla') ? parsed.color :\n    convert.toJSON(convert.toHsla($color));\n  const toOriginalColorType = newColor => convert[subScript](newColor);\n  return { color, toOriginalColorType };\n};\n\n\nexport default convenienceToHsla;\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/convenience-to-hsla.js","import * as hsl from './hsl';\n\n\n/**\n * HSL => HSL\n * \n * Returns the result of hsl.toHsl, as the alpha channel is \n * irrelavent.\n * @param {object} hslColor\n * @returns {string} - HSL CSS string\n */\nexport const toHsl = hslaColor => hsl.toHsl(hslaColor);\n\n\n/**\n * HSL => HSLA\n * \n * Returns the result of hsl.toHsl, changes prefix to hsla and\n * appends the hslaColor's alpha channel.\n * @param {object} hslColor\n * @returns {string} - HSLA CSS string\n */\nexport const toHsla = (hslaColor) => {\n  const { a } = hslaColor;\n  return `hsla${hsl.toHsl(hslaColor).slice(3, -1)},${a})`;\n};\n\n\n/**\n * HSL => Hex\n * \n * Returns the result of hsl.toHex, as the alpha channel is \n * irrelavent.\n * @param {object} hslColor\n * @returns {string} - Hex CSS string\n */\nexport const toHex = hslaColor => hsl.toHex(hslaColor);\n\n\n/**\n * HSL => RGB\n * \n * Returns the result of hsl.toRgb, as the alpha channel is \n * irrelavent.\n * @param {object} hslaColor\n * @returns {string} - RGB CSS string\n */\nexport const toRgb = hslaColor => hsl.toRgb(hslaColor);\n\n\n/**\n * HSL => RGBA\n * \n * Returns the result of hsl.toRgb, changes prefix to rgba and\n * appends the hslaColor's alpha channel.\n * @param {object} hslColor\n * @returns {string} - RGBA CSS string\n */\nexport const toRgba = (hslaColor) => {\n  const { a } = hslaColor;\n  return `rgba${hsl.toRgb(hslaColor).slice(3, -1)},${a})`;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/conversions/hsla.js","import * as rgb from './rgb';\n\n/**\n * RGBA => HSL\n * \n * Calls rgb.toHsl method as the alpha channel is irrelavent.\n * @param {object} rgbaColor\n * @returns {string} - HSL CSS string\n */\nexport const toHsl = rgbaColor => rgb.toHsl(rgbaColor);\n\n\n/**\n * RGBA => HSLA\n * \n * Returns the result of rgb.toHsl, changes prefix to hsla and \n * appends the rgbaColor's alpha channel.\n * @param {object} rgbaColor\n * @returns {string} - HSLA CSS string\n */\nexport const toHsla = (rgbaColor) => {\n  const { a } = rgbaColor;\n  return `hsla${rgb.toHsl(rgbaColor).slice(3, -1)},${a})`;\n};\n\n\n/**\n * RGBA => Hex\n * \n * Calls rgb.toHex method as the alpha channel is irrelavent.\n * @param {object} rgbaColor\n * @returns {string} - Hex CSS string\n */\nexport const toHex = rgbaColor => rgb.toHex(rgbaColor);\n\n\n/**\n * RGBA -> RGB\n * \n * Calls rgb.toRgb method as the alpha channel is irrelavent.\n * @param {object} rgbaColor\n * @returns {string} - RGB CSS string\n */\nexport const toRgb = rgbaColor => rgb.toRgb(rgbaColor);\n\n\n/**\n *  RGBA => RGBA\n * \n * Returns the result of rgb.toHsl, changes prefix to rgba and\n * appends the rgbaColor's alpha channel.\n * @param {object} rgbaColor\n * @returns {string} - RGBA CSS string\n */\nexport const toRgba = (rgbaColor) => {\n  const { a } = rgbaColor;\n  return `rgba${rgb.toRgba(rgbaColor).slice(3, -1)},${a})`;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/conversions/rgba.js","export { lighten, darken } from './luminance';\nexport { saturate, desaturate } from './saturation';\nexport { opacify, transparentize } from './opacity';\n\n\n\n// WEBPACK FOOTER //\n// ./src/manipulations/index.js","import { convenienceToHsla } from '../utils';\n\n\n/**\n * Alters color's luminance value\n * \n * Parses color, converts it to HSLA (for easy manipulation),\n * reduces/increases the luminance value according to the factor\n * if possible. Finally, it is converted to it's original format \n * and returned via a convenience closure.\n * @param {string|object} $color \n * @param {number} factor\n * @returns {string} - [type] CSS string\n */\nconst alterLuminance = ($color, factor) => {\n  if (factor > 1 || factor < -1) throw new Error('Invalid factor');\n  const { color, toOriginalColorType } = convenienceToHsla($color);\n  let lum = color.l;\n  const adjLum = lum + factor;\n  // keep luminance bound to range of [0 - 1]\n  if (adjLum <= 1 && adjLum >= 0) lum = adjLum;\n  else { console.warn('lum out of bounds'); lum = adjLum > 0.5 ? 1 : 0; }\n  return toOriginalColorType({ ...color, l: lum });\n};\n\n\n/**\n * Lightens color\n * \n * Calls alterLuminance function with a positive factor, making\n * the luminance value increase. \n * @param {string|object} color\n * @param {number} factor \n */\nexport const lighten = (color, factor = 0.1) => alterLuminance(color, factor);\n\n\n/**\n * Darkens color\n * \n * Calls alterLuminance function with a negitive factor, making\n * the luminance value decrease.\n * @param {string|object} color\n * @param {number} factor \n */\nexport const darken = (color, factor = 0.1) => alterLuminance(color, -factor);\n\n\n\n// WEBPACK FOOTER //\n// ./src/manipulations/luminance.js","import { convenienceToHsla } from '../utils';\n\n\n/**\n * Alters color's saturation value\n * \n * Parses color, converts it to HSLA (for easy manipulation),\n * reduces/increases the saturation value according to the factor\n * if possible. Finally, it is converted to it's original format \n * and returned via a convenience closure.\n * @param {string|object} $color \n * @param {number} factor\n * @returns {string} - [type] CSS string\n */\nconst alterSaturation = ($color, factor) => {\n  if (factor > 1 || factor < -1) throw new Error('Invalid factor');\n  const { color, toOriginalColorType } = convenienceToHsla($color);\n  let sat = color.s;\n  const adjSat = sat + factor;\n  // keep saturation bound to range of [0 - 1]\n  if (adjSat <= 1 && adjSat >= 0) sat = adjSat;\n  else { console.warn('sat out of bounds'); sat = adjSat > 0.5 ? 1 : 0; }\n  return toOriginalColorType({ ...color, s: sat });\n};\n\n\n/**\n * Saturates color\n * \n * Calls alterSaturation function with a positive factor, making\n * the saturation value increase by the factor.\n * @param {string|object} color\n * @param {number} factor\n * @returns {string} - [type] CSS string\n */\nexport const saturate = (color, factor = 0.1) => alterSaturation(color, factor);\n\n\n/**\n * Desaturates color\n * \n * Calls alterSaturation function with a negative factor, making\n * the saturation value decrease by the factor.\n * @param {string|object} color \n * @param {number} factor \n * @returns {string} - [type] CSS string\n */\nexport const desaturate = (color, factor = 0.1) => alterSaturation(color, -factor);\n\n\n\n// WEBPACK FOOTER //\n// ./src/manipulations/saturation.js","import { convenienceToHsla } from '../utils';\n\n\n/**\n * Alters color's alpha chanel\n * \n * Parses color, converts it to HSLA (for easy manipulation),\n * reduces/increases the alpha channel according to the factor\n * if possible. Finally, it is converted to it's original format \n * and returned via a convenience closure.\n * @param {string|object} $color \n * @param {number} factor\n * @returns {string} - [type] CSS string\n */\nconst alterOpacity = ($color, factor) => {\n  if (factor > 1 || factor < -1) throw new Error('Invalid factor');\n  const { color, toOriginalColorType } = convenienceToHsla($color);\n  let alpha = color.a;\n  const adjAlpha = alpha + factor;\n  // keep alpha channel bound to range of [0 - 1]\n  if (adjAlpha <= 1 && adjAlpha >= 0) alpha = adjAlpha;\n  else { console.warn('alpha out of bounds'); alpha = adjAlpha > 0.5 ? 1 : 0; }\n  return toOriginalColorType({ ...color, a: alpha });\n};\n\n\n/**\n * Opacifies color\n * \n * Calls alterOpacity function with a positive factor, making\n * the alpha channel increase by the factor.\n * @param {*}  \n * @param {*} factor \n */\nexport const opacify = (color, factor = 0.1) => alterOpacity(color, factor);\n\n\n/**\n * Transparentizes color\n * \n * Calls alterOpacity function with a negative factor, making\n * the alpha channel decrease by the factor.\n * @param {*} color \n * @param {*} factor \n */\nexport const transparentize = (color, factor = 0.1) => alterOpacity(color, -factor);\n\n\n\n// WEBPACK FOOTER //\n// ./src/manipulations/opacity.js"],"sourceRoot":""}